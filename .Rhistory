flex_window_hours = 6,
time_horizon = 12
)
)
})
opt_data %>%
mutate(
flexible = building
) %>%
select(-production) %>%
optimize_demand(
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
opt_data %>%
mutate(
flexible = building
) %>%
select(-production) %>%
optimize_demand(
opt_data = .,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
opt_data <- flextools::energy_profiles %>%
filter(lubridate::isoweek(datetime) == 18) %>%
rename(
production = "solar"
)
opt_data %>%
mutate(
flexible = building
) %>%
select(-production) %>%
optimize_demand(
opt_data = .,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
test_that("Get error when missing `production` column in `opt_data`", {
expect_error(
opt_data2 <- opt_data %>%
mutate(
flexible = building
) %>%
select(-production)
opt_data2 %>%
test_that("Get error when missing `production` column in `opt_data`", {
opt_data2 <- opt_data %>%
mutate(
flexible = building
) %>%
select(-production)
expect_error(
opt_data2 %>%
optimize_demand(
opt_data = .,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
)
})
opt_data2 <- opt_data %>%
mutate(
flexible = building
) %>%
select(-production)
opt_data2
opt_data2 %>%
optimize_demand(
opt_data = .,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
expect_error(
optimize_demand(
opt_data = opt_data2,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
)
test_that("Get error when missing `production` column in `opt_data`", {
opt_data2 <- opt_data %>%
mutate(
flexible = building
) %>%
select(-production)
expect_message(
optimize_demand(
opt_data = opt_data2,
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
)
})
test_that("Get error when missing `production` column in `opt_data`", {
expect_message(
opt_data %>%
mutate(
flexible = building
) %>%
select(-production) %>%
optimize_demand(
opt_objective = "grid",
direction = "forward",
flex_window_hours = 6,
time_horizon = 12
)
)
})
test_that("Get message when missing `flex_window_hours` is too high", {
expect_message(
opt_data %>%
mutate(
flexible = building
) %>%
optimize_demand(
opt_objective = "grid",
direction = "forward",
window_days = 1,
flex_window_hours = 48
)
)
})
opt_data %>%
mutate(
flexible = building
) %>%
optimize_demand(
opt_objective = "grid",
direction = "forward",
window_days = 1,
flex_window_hours = 48
)
devtools::load_all(".")
opt_data %>%
mutate(
flexible = building
) %>%
optimize_demand(
opt_objective = "grids",
direction = "backward",
window_days = 2
)
test_that("error when `opt_objective` is wrong in optimization demand", {
expect_error(
opt_data %>%
mutate(
flexible = building
) %>%
optimize_demand(
opt_objective = "grids",
direction = "backward",
window_days = 2
)
)
})
test_that("error when `opt_objective` is wrong in battery optimization", {
expect_error(
opt_data %>%
select(any_of(c(
"datetime", "production", "building", "price_imported", "price_exported"
))) %>%
mutate(
static = .data$building
) %>%
add_battery_optimization(
opt_objective = "grids",
Bcap = 50, Bc = 4, Bd = 4,
window_start_hour = 5
)
)
})
opt_data %>%
select(any_of(c(
"datetime", "production", "building", "price_imported", "price_exported"
))) %>%
mutate(
static = .data$building
) %>%
add_battery_optimization(
opt_objective = "grids",
Bcap = 50, Bc = 4, Bd = 4,
window_start_hour = 5
)
devtools::test_coverage()
devtools::test_coverage()
usethis::use_coverage()
devtools::build_readme()
use_github_action("test-coverage")
usethis::use_github_action("test-coverage")
pkgdown::preview_site()
pkgdown::build_site()
pkgdown::preview_site()
usethis::use_coverage()
pkgdown::build_site()
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.5)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
library(testthat)
library(flextools)
library(dplyr)
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.5)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
# Use first 50 sessions
sessions <- evsim::california_ev_sessions_profiles %>%
slice_head(n = 50) %>%
evsim::adapt_charging_features(time_resolution = 15)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)
# Don't require any other variable than datetime, since we don't
# care about local generation (just peak shaving objective)
opt_data <- tibble(
datetime = sessions_demand$datetime,
production = 0
)
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.5)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
sc_results
sessions
8/50*100
sc_results$sessions %>%
select(all_of(c("Session", "Responsive", "Flexible", "Exploited"))) %>%
group_by(.data$Session) %>%
summarise_all(sum, na.rm = TRUE)
sc_results$sessions
ss <- sc_results$sessions
View(ss)
sc_results$sessions %>%
select(all_of(c("Session", "Responsive", "Flexible", "Exploited"))) %>%
group_by(.data$Session) %>%
summarise_all(sum, na.rm = TRUE)
View(ss)
devtools::load_all(".")
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.5)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
ss <- sc_results$sessions
sc_results$log$`2018-10-08`$Worktime[[1]]
sessions
sc_results$log$`2018-10-08`$Worktime[[2]]
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 1)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
sc_results$log$`2018-10-08`$Worktime[[1]]
plot(sc_results)
2.06/4
sessions
2.19*0.6
2.19+0.6
plot_smart_charging(sc_results, sessions)
2.79-2.66
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.5)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
sc_results$log$`2018-10-08`$Worktime[[1]]
plot_smart_charging(sc_results, sessions)
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 1)),
charging_power_min = 2, include_log = TRUE, show_progress = TRUE
)
sc_results$log$`2018-10-08`$Worktime[[1]]
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 1))
)
sc_results$log$`2018-10-08`$Worktime[[1]]
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 1)), include_log = TRUE
)
sc_results$log$`2018-10-08`$Worktime[[1]]
sc_results$log$`2018-10-08`$Worktime[[2]]
ss <- sc_results$sessions
View(sessions)
max(list())
max(list(), 100)
max(c(), 100)
devtools::load_all(".")
library(dplyr)
# Use first 50 sessions
sessions <- evsim::california_ev_sessions_profiles %>%
slice_head(n = 50) %>%
evsim::adapt_charging_features(time_resolution = 15)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)
# Don't require any other variable than datetime, since we don't
# care about local generation (just peak shaving objective)
opt_data <- tibble(
datetime = sessions_demand$datetime,
production = 0
)
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6,
responsive = list(Workday = list(Worktime = 0.9)),
energy_min = 0.5, include_log = TRUE, show_progress = TRUE
)
view_logs(sc_results)
class(view_logs(sc_results))
devtools::load_all(".")
# To test log viewer
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6, energy_min = 0,
include_log = TRUE, show_progress = TRUE
)
view_logs(sc_results)
devtools::load_all(".")
# To test log viewer
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6, energy_min = 0,
include_log = TRUE, show_progress = TRUE
)
view_logs(sc_results)
tools::showNonASCIIfile
tools::showNonASCIIfile()
tools::showNonASCIIfile("R/smart-charging.R")
devtools::load_all(".")
# To test log viewer
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6, energy_min = 0,
include_log = TRUE, show_progress = TRUE
)
view_logs(sc_results)
devtools::load_all(".")
# To test log viewer
sc_results <- smart_charging(
sessions, opt_data, opt_objective = "grid", method = "curtail",
window_days = 1, window_start_hour = 6, energy_min = 0,
include_log = TRUE, show_progress = TRUE
)
view_logs(sc_results)
pkgdown::build_site()
pkgdown::build_site()
get_demand
evsim::get_demand
get_sd_factor <- function(pct = 95) {
qnorm(1 - (1 - pct / 100) / 2)
}
get_sd_factor(95)
get_sd_factor(99)
get_sd_factor(90)
??qnorm
pkgdonwn::build_site()
pkgdown::build_site()
library(dplyr)
# Use first 50 sessions
sessions <- evsim::california_ev_sessions_profiles %>%
slice_head(n = 50) %>%
evsim::adapt_charging_features(time_resolution = 15)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)
# Don't require any other variable than datetime, since we don't
# care about local generation (just peak shaving objective)
opt_data <- tibble(
datetime = sessions_demand$datetime,
production = 0
)
opt_objective = "grid"
method = "curtail"
window_days = 1
window_start_hour = 6
opt_data$flexible <- 0
opt_data <- check_optimization_data(opt_data, opt_objective)
devtools::load_all(".")
opt_data <- check_optimization_data(opt_data, opt_objective)
responsive = NULL
if (is.null(responsive)) {
responsive <- map(
set_names(unique(sessions$Timecycle)),
~ map(
set_names(unique(sessions$Profile)),
~ 1
)
)
} else {
responsive_time_cycles <- names(responsive)
responsive_user_profiles <- unlist(map(responsive, names))
sessions_time_cycles <- unique(sessions$Timecycle)
sessions_user_profiles <- unique(sessions$Profile)
# Check that all content in `responsive` match the content in `sessions`
if (!all(responsive_time_cycles %in% sessions_time_cycles)) {
message("Warning: time cycle name in `responsive` not found in `sessions`")
# return( NULL )
}
if (!all(responsive_user_profiles %in% sessions_user_profiles)) {
message("Warning: user profile name in `responsive` not found in `sessions`")
# return( NULL )
}
}
# Adapt the data set for the current time resolution
dttm_seq <- opt_data$datetime
time_resolution <- get_time_resolution(dttm_seq, units = "mins")
sessions <- sessions %>%
adapt_charging_features(time_resolution = time_resolution)
# Optimization windows according to `window_days` and `window_start_hour`
flex_windows_idx <- get_flex_windows(
dttm_seq, window_days, window_start_hour
)
# Get user profiles demand
if (show_progress) cli::cli_progress_step("Calculating EV demand")
profiles_demand <- get_demand(
sessions, dttm_seq, mc.cores = mc.cores
)
mc.cores <- 8
profiles_demand <- get_demand(
sessions, dttm_seq, mc.cores = mc.cores
)
# Initialize setpoints tibble with the user profiles demand
setpoints <- profiles_demand
profiles_demand
# For each optimization window
n_windows <- nrow(flex_windows_idx)
log_window_name <- NULL
# Split sessions among windows
sessions_windows <- pmap(
flex_windows_idx,
~ sessions %>%
filter(
.data$ChargingStartDateTime >= dttm_seq[..1],
.data$ChargingStartDateTime <= dttm_seq[..2]
)
)
sessions_windows
sessions <- evsim::california_ev_sessions_profiles
time_resolution
sessions <- sessions %>%
adapt_charging_features(time_resolution = time_resolution)
# Optimization windows according to `window_days` and `window_start_hour`
flex_windows_idx <- get_flex_windows(
dttm_seq, window_days, window_start_hour
)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)
# Use first 50 sessions
sessions <- evsim::california_ev_sessions_profiles %>%
slice_head(n = 100) %>%
evsim::adapt_charging_features(time_resolution = 15)
sessions_demand <- evsim::get_demand(sessions, resolution = 15)
# Don't require any other variable than datetime, since we don't
# care about local generation (just peak shaving objective)
opt_data <- tibble(
datetime = sessions_demand$datetime,
production = 0
)
opt_data$flexible <- 0
opt_data <- check_optimization_data(opt_data, opt_objective)
if (show_progress) cli::cli_progress_step("Defining optimization windows")
# Adapt the data set for the current time resolution
dttm_seq <- opt_data$datetime
time_resolution <- get_time_resolution(dttm_seq, units = "mins")
sessions <- sessions %>%
adapt_charging_features(time_resolution = time_resolution)
# Optimization windows according to `window_days` and `window_start_hour`
flex_windows_idx <- get_flex_windows(
dttm_seq, window_days, window_start_hour
)
profiles_demand <- get_demand(
sessions, dttm_seq, mc.cores = mc.cores
)
# Initialize setpoints tibble with the user profiles demand
setpoints <- profiles_demand
# Split sessions among windows
sessions_windows <- pmap(
flex_windows_idx,
~ sessions %>%
filter(
.data$ChargingStartDateTime >= dttm_seq[..1],
.data$ChargingStartDateTime <= dttm_seq[..2]
)
)
sessions_windows
View(sessions)
object.size(sessions)
object.size(sessions_windows)

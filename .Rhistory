import numpy as np
import pandas as pd
vec = np.array([0, 0, 0, 0, 0, 0])
chs = 2
che
che = 5
s = {'chs': 2, 'che':5, 'p':5}
s['chs']
vec[(vec >= s['chs']) & (vec < s['che']), [profile]] += s['p']
vec[(vec >= s['chs']) & (vec < s['che'])] += s['p']
vec
vec[(vec >= s['chs']) & (vec < s['che'])]
vecdf = pd.DataFrame(vec, index = range(len(vec)), columns = 'profile')
vecdf = pd.DataFrame(vec, index = range(len(vec)), columns = ['profile'])
vecdf
vecdf.loc[(vecdf.index >= s['chs']) & (vecdf.index < s['che']), ['profile']] += s['p']
vecdf
vecdf.loc[(vecdf.index >= s['chs']) & (vecdf.index < s['che']), 'profile'] += s['p']
profile = 'profile'
vecdf.loc[(vecdf.index >= s['chs']) & (vecdf.index < s['che']), profile] += s['p']
vecdf
216.3-158.02
205.3-139.76
?rlang::.data
?rbind
pmax(2, 3)
pmax(2, 2)
pmax(2, 4)
pmax(2, 1)
?round_date
l
seq(1, 1, 1)
seq(1, 1, 100)
window
window <- c(0, 96)
window[1]:window[2]
length(window[1]:window[2])
seq(window[1], window[2])
0+96
t1
tibble(a = c(1, 2, 3, 4), b = c(5, 6, 7, 8))
library(dplyr)
tibble(a = c(1, 2, 3, 4), b = c(5, 6, 7, 8))
t1 <- tibble(a = c(1, 2, 3, 4), b = c(5, 6, 7, 8))
start <- Sys.time();t1[['a']];Sys.time()-start
start <- Sys.time();t1$a;Sys.time()-start
start <- Sys.time();between(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 4, 6);Sys.time()-start
start <- Sys.time();(c(1, 2, 3, 4, 5, 6, 7, 8, 9)>=4 & c(1, 2, 3, 4, 5, 6, 7, 8, 9)<=6);Sys.time()-start
start <- Sys.time();sum(between(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 4, 6));Sys.time()-start
start <- Sys.time();6-4+1;Sys.time()-start
min(c(1, 2, 3, 4, NA, 5, 6))
1.825/2
3.7*0.25
7.3*0.25
1.825*4
1.825*4
3.7*2
3.7*2
7.4*2
renv::update()
sessionInfo('data.table')
round(c(2.43333, 3.36366), 4)
install.packages('roxygen2')
install.packages(c('dtplyr', 'osqp'))
install.packages('tinytex')
install.packages('testthat')
install.packages('devtools')
sample(c(T, F), 10, replace = T, prob = c(1, (1-1)))
pmin(3, 5)
pmin(8, 5)
as.numeric(now()+minutes(3) - now(), unit = 'hours')
library(lubridate)
as.numeric(now()+minutes(3) - now(), unit = 'hours')
as.numeric(now()+minutes(3) - now(), unit = 'hours')*60
time_horizon = 3
time_slots = 8
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -time_horizon)
triangulate_matrix <- function(mat, direction = c('l', 'u'), k=0) {
if (direction == 'l') {
return( as.matrix(Matrix::tril(mat, k = k)) )
} else if (direction == 'u') {
return( as.matrix(Matrix::triu(mat, k = k)) )
} else {
message('Error: not valid direction.')
return( NULL )
}
}
# Matrices for constraints
identityMat <- diag(time_slots)
identityMat
cumsumMat <- triangulate_matrix(matrix(1, time_slots, time_slots), 'l')
cumsumMat
triangulate_matrix(matrix(1, time_slots, time_slots), "l", -time_horizon)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", -8)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", -7)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -8)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -9)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -8)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "u"), "l", 8)
triangulate_matrix(matrix(1, time_slots, time_slots), "u")
triangulate_matrix(matrix(1, time_slots, time_slots), "l", 8)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", -8)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", 8)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", -time_horizon)
triangulate_matrix(matrix(1, time_slots, time_slots), "u", time_horizon)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", 8)
triangulate_matrix(matrix(1, time_slots, time_slots), "l", 9)
horizonMat_cumsum
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -time_horizon)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -8)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "l"), "u", -9)
triangulate_matrix(triangulate_matrix(matrix(1, time_slots, time_slots), "u"), "l", 8)
is.integer(4)
as.integer(4)
as.integer(4.2)
4.2 %% 1
g <- rep(4, 24*4)
g
length(g)
window_length <- 24
seq(1, (length(G)/window_length), window_length)
G <- g
seq(1, (length(G)/window_length), window_length)
(length(G)/window_length)
seq(1, length(G), window_length)
73+24
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = seq(flex_start, flex_end)
)
library(tibble)
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = seq(flex_start, flex_end)
)
flex_window_length <- 6
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = seq(flex_start, flex_end)
)
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = map2_int(flex_start, flex_end, ~ seq(.x, .y))
)
library(purrr)
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = map2_int(flex_start, flex_end, ~ seq(.x, .y))
)
tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length
)
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length,
flex_seq = map2(flex_start, flex_end, ~ seq(.x, .y))
)
windows_idxs
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length - 1,
flex_seq = map2(flex_start, flex_end, ~ seq(.x, .y))
)
windows_idxs
window_length <- length(G)
flex_window_length <- window_length
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length - 1,
flex_seq = map2(flex_start, flex_end, ~ seq(.x, .y))
)
windows_idxs
window_length <- 24
flex_window_length <- 6
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length - 1,
flex_seq = map2(flex_start, flex_end, ~ seq(.x, .y))
)
windows_idxs
windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length - 1,
flex_idx = map2(flex_start, flex_end, ~ seq(.x, .y))
)
flex_windows_idxs <- tibble(
flex_start = seq(1, length(G), window_length),
flex_end = flex_start + flex_window_length - 1,
flex_idx = map2(flex_start, flex_end, ~ seq(.x, .y))
)
install.packages('schoolmath')
schoolmath::is.decimal
list(Monday = list(Worktime = 100, Shortstay = 10))
library(dplyr)
library(purrr)
library(dplyr)
windows_length <- c(10, 5, 10)
map(
1:seq_len(length(windows_length)),
~ rep(.x, times = windows_length[.x])
)
length(windows_length)
seq_len(length(windows_length))
map(
seq_len(length(windows_length)),
~ rep(.x, times = windows_length[.x])
)
unlist(map(
seq_len(length(windows_length)),
~ rep(.x, times = windows_length[.x])
))
library(ROI)
install.packages("ROI.plugin.osqp")
?ROI.plugin.osqp:::
remotes::install_github("mcanigueral/evprof")
sessions <- evprof::california_ev_sessions
sessions
source("~/Resourcefully Dropbox/Marc Canigueral/PROJECTS/R PACKAGES/flextools/R/preprocessing.R", echo=TRUE)
sessions_demand <- get_sessions_demand(sessions)
library(lubridate)
sessions_demand <- get_sessions_demand(sessions)
library(dtplyr)
########################################################### delete
sessions <- evprof::california_ev_sessions
tibble(a = c(1, 2), b = c(4, 5)) %>% min
library(dplyr)
tibble(a = c(1, 2), b = c(4, 5)) %>% min
source("~/Resourcefully Dropbox/Marc Canigueral/PROJECTS/R PACKAGES/flextools/R/preprocessing.R", echo=TRUE)
devtools::load_all(".")
-1e-2
24*60
1440/(15*60)
sessions <- readRDS("stest.RDS")
sessions
library(dplyr)
sessions_window_prof <- sessions %>% filter(profile == "Worktime", date(ConnectionStartDateTime) == dmy(01012030))
sessions_window_prof <- sessions %>% filter(date(ConnectionStartDateTime) == dmy(01012030))
library(datetime)
library(lubridate)
sessions_window_prof <- sessions %>% filter(profile == "Worktime", date(ConnectionStartDateTime) == dmy(01012030))
sessions_window_prof <- sessions %>% filter(date(ConnectionStartDateTime) == dmy(01012030))
sessions_window_prof <- sessions %>% filter(Profile == "Worktime", date(ConnectionStartDateTime) == dmy(01012030))
sessions_window_prof
# The smart charging algorithm only allows moving demand within the
# time-window, so:
#   1. Limit the CONNECTION END TIME of sessions that FINISH CHARGING BEFORE the window end
sessions_window_prof$ConnectionEndDateTime[
(sessions_window_prof$ConnectionEndDateTime >= dttm_seq[window[2]]) &
(sessions_window_prof$ChargingEndDateTime <= dttm_seq[window[2]])
] <- dttm_seq[window[2]]
ecdf(sessions_window_prof$ConnectionEndDateTime)
# Re-define window to profile's connection window
# Find the End time for at least 95% of sessions
ss_ecdf <- ecdf(as.numeric(sessions_window_prof$ConnectionEndDateTime))
ss_coe_ecdf <- round(ss_ecdf(knots(ss_ecdf)), 1)
ss_coe_ecdf
ss_coe_ecdf <- round(ss_ecdf(knots(ss_ecdf)), 2)
ss_coe_ecdf
as.numeric(sessions_window_prof$ConnectionEndDateTime)
ecdf(as.numeric(sessions_window_prof$ConnectionEndDateTime)) %>% plot()
as.numeric(sessions_window_prof$ConnectionEndDateTime) %>% mean
as.numeric(sessions_window_prof$ConnectionEndDateTime) %>% sd
# Using the rule mean+-2*sd (95.45%) for the start and end times
start_time_mean <- mean(as.numeric(sessions_window_prof$ConnectionStartDateTime))
start_time_sd <- sd(as.numeric(sessions_window_prof$ConnectionStartDateTime))
end_time_mean <- mean(as.numeric(sessions_window_prof$ConnectionEndDateTime))
end_time_sd <- sd(as.numeric(sessions_window_prof$ConnectionEndDateTime))
sessions_window_prof %>%
filter(
between(
as.numeric(ConnectionStartDateTime),
start_time_mean - 2*start_time_sd,
start_time_mean + 2*start_time_sd
),
between(
as.numeric(ConnectionEndDateTime),
end_time_mean - 2*end_time_sd,
end_time_mean + 2*end_time_sd
)
)
minutes(time_resolution)
minutes(15)
minutes(15) %>% as.numeric()
15*60
sessions_window_prof %>%
filter(
between(
as.numeric(ConnectionStartDateTime),
round_to_interval(start_time_mean - 2*start_time_sd, time_resolution*60),
round_to_interval(start_time_mean + 2*start_time_sd, time_resolution*60)
),
between(
as.numeric(ConnectionEndDateTime),
round_to_interval(end_time_mean - 2*end_time_sd, time_resolution*60),
round_to_interval(end_time_mean + 2*end_time_sd, time_resolution*60)
)
)
#' Round a numeric value to interval
#'
#' @param dbl numeric value
#' @param interval decimal interval (from 0 to 1)
#'
#' @keywords internal
#'
round_to_interval <- function (dbl, interval) {
round(dbl/interval) * interval
}
sessions_window_prof %>%
filter(
between(
as.numeric(ConnectionStartDateTime),
round_to_interval(start_time_mean - 2*start_time_sd, time_resolution*60),
round_to_interval(start_time_mean + 2*start_time_sd, time_resolution*60)
),
between(
as.numeric(ConnectionEndDateTime),
round_to_interval(end_time_mean - 2*end_time_sd, time_resolution*60),
round_to_interval(end_time_mean + 2*end_time_sd, time_resolution*60)
)
)
time_resolution <- 15
sessions_window_prof %>%
filter(
between(
as.numeric(ConnectionStartDateTime),
round_to_interval(start_time_mean - 2*start_time_sd, time_resolution*60),
round_to_interval(start_time_mean + 2*start_time_sd, time_resolution*60)
),
between(
as.numeric(ConnectionEndDateTime),
round_to_interval(end_time_mean - 2*end_time_sd, time_resolution*60),
round_to_interval(end_time_mean + 2*end_time_sd, time_resolution*60)
)
)
library(flextools)
unlist(c(1, 2, 4))
library(flextools)
pkgload::dev_help('reexports')
library(flextools)
